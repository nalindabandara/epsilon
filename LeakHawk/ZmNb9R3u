package takr2;

import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.Base64.*;

import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.interfaces.DHPublicKey;
import javax.crypto.spec.DHParameterSpec;
import javax.crypto.spec.DHPublicKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class ProtocolSec {

	private Signature sign;
	private KeyPair keyPair;
	
	private KeyAgreement aKeyAgree;
	private byte[] pass;
	
	private Decoder dec = Base64.getDecoder();
	private Encoder enc = Base64.getEncoder();
	

	
	/**
	 * Generuje RSA
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeyException
	 */
	public void genRSA() throws NoSuchAlgorithmException, InvalidKeyException{
		
		//--------------- Generovani a inicializace RSA algoritmu pro podpis, verze 2048 b, SHA512----
		KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
		keyGen.initialize(2048, new SecureRandom());
		keyPair = keyGen.generateKeyPair();
		sign = Signature.getInstance("SHA512withRSA");
		sign.initSign(keyPair.getPrivate());
		//---------------------------------------------
	}
	
	public String getPublicKey(){
		
		return enc.encodeToString(keyPair.getPublic().getEncoded());
	}
	
	/**
	 * Podepisuje data
	 * Vstup i vystup kodovan v BASE64!
	 * @param data
	 * @return
	 * @throws SignatureException
	 * @throws NoSuchAlgorithmException 
	 * @throws InvalidKeyException 
	 */
	public String sign(String data) throws SignatureException, NoSuchAlgorithmException, InvalidKeyException{
		
		//--------------- RSA podepsani, stup: data----
		Signature s = Signature.getInstance("SHA512withRSA");
		s.initSign(keyPair.getPrivate());
		s.update(dec.decode(data));
		byte[] signature = s.sign(); 

		//---------------------------------------------
		return enc.encodeToString(signature);
	}
	
	/**
	 * generovani Diffie Hellman
	 * Vraci verejny klic v BASE64!
	 */
	public String genDH() throws Exception{
		
		byte[] pubA = null;
		//--------------- Diffie helman, inicializace a vraceni verejneho klice----
		KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DH");
		aKeyAgree = KeyAgreement.getInstance("DH");
		keyPair = keyGen.generateKeyPair();
		aKeyAgree.init(keyPair.getPrivate());
		pubA = keyPair.getPublic().getEncoded();
		
	    //-------------------------------------------------------------------------
	   return enc.encodeToString(pubA);
	}
	
	/**
	 * inicializuje algoritmus DH klicem PK protistrany, 
	 * vypocte sdilene tajemstvi
	 * vzpocte hash a vrati jej
	 * Vstup kodovan BASE64!
	 * @param pk
	 * @throws Exception
	 */
	public void procDH(String pk) throws Exception {
		
		
		byte[] bpk = dec.decode(pk.getBytes());
		//--------------- Diffie Hellman , hash SHA1 -----------------------
		PublicKey publicB = KeyFactory.getInstance("DH").generatePublic(new X509EncodedKeySpec(bpk));
		aKeyAgree.doPhase(publicB, true);
		MessageDigest hash = MessageDigest.getInstance("SHA1"); 
		pass = hash.digest(hash.digest(aKeyAgree.generateSecret()));
		//Hash ulozit do pass - pouziva se na sifrovani
		//-------------------------------------------------------------------
	}
	
	/**
	 * Sifrování, vstup není kódován BASE64!
	 * Výstup kódován BASE64!
	 * @param data
	 * @return
	 * @throws Exception
	 */
	public String encrypt(String data) throws Exception{
		
		byte[] encAes = null;
		
		//--------------- inicializace, sifrovani AES-128, mod ECB, padding PKCS5Padding----
		Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
		SecretKey key = new	SecretKeySpec(pass, 0, 16, "AES");
		c.init(Cipher.ENCRYPT_MODE, key);
		encAes = c.doFinal(data.getBytes());
		//----------------------------------------
		return enc.encodeToString(encAes);
	}
	
	/**
	 * Desifrování, vstup je kódován BASE64!
	 * Výstup kódován BASE64!
	 * @param data
	 * @return
	 * @throws Exception
	 */
	public String decrypt(String data) throws Exception{
		
		byte[] decAes = null;
		//--------------- inicializace, desifrovani AES-128, mod ECB, padding PKCS5Padding---
		Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
		SecretKey key = new	SecretKeySpec(pass, 0, 16, "AES");
		c.init(Cipher.DECRYPT_MODE, key);
		decAes = c.doFinal(dec.decode(data));
		//-------------------------------------------------------------------
		return new String(decAes);
	}


}
